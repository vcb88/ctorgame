import { useEffect, useState, useCallback, useRef } from 'react';
import { logger } from '../utils/logger';
import { GameStateManager } from '../services/GameStateManager';
import { type GameSocket } from '../services/socket';

// Shared types
import type { 
    IGameState, 
    IGameMove, 
    PlayerNumber,
    GameStatus
} from '@ctor-game/shared/src/types/game/types.js';
import type { 
    IWebSocketEvent, 
    UUID,
    ServerToClientEvents,
    ClientToServerEvents
} from '@ctor-game/shared/src/types/network/websocket.js';
import type { 
    INetworkError
} from '@ctor-game/shared/src/types/network/errors.js';
import type {
    IPosition
} from '@ctor-game/shared/src/types/geometry/types.js';

import { getSocket } from '../services/socket';

type ConnectionState = 'connected' | 'connecting' | 'reconnecting' | 'disconnected' | 'error';

interface IGameResponse {
    readonly success: boolean;
    readonly error?: INetworkError;
    readonly eventId?: UUID;
    readonly timestamp: number;
}

interface IJoinGameResponse extends IGameResponse {
    readonly gameId?: UUID;
    readonly playerNumber?: PlayerNumber;
}

interface IMultiplayerGameState {
    readonly gameId: UUID | null;
    readonly playerNumber: PlayerNumber | null;
    readonly gameState: IGameState | null;
    readonly currentPlayer: PlayerNumber;
    readonly connectionState: ConnectionState;
    readonly error: INetworkError | null;
    readonly availableReplaces: IGameMove[];
    readonly timestamp: number;
}

export const useMultiplayerGame = () => {
  // Log hook initialization
  logger.debug('useMultiplayerGame hook initialized', {
    component: 'useMultiplayerGame',
    data: {
      timestamp: Date.now(),
      existingSocket: !!getSocket()
    }
  });
  // Initialize GameStateManager singleton
  const gameManager = useRef<GameStateManager>(GameStateManager.getInstance());
  const socket = useRef<GameSocket>(getSocket());
  
  // Initialize state from GameStateManager
  const [state, setState] = useState<IMultiplayerGameState>(() => {
    const managerState = gameManager.current.getState();
    return {
      gameId: managerState.gameId,
      playerNumber: managerState.playerNumber,
      gameState: managerState.gameState,
      currentPlayer: managerState.currentPlayer,
      connectionState: managerState.connectionState as ConnectionState,
      error: managerState.error,
      availableReplaces: managerState.availableReplaces,
      timestamp: managerState.timestamp
    };
  });

  // Function to clear game state from localStorage
  const clearGameState = useCallback(() => {
    localStorage.removeItem('gameId');
    localStorage.removeItem('playerNumber');
    localStorage.removeItem('gameState');
    localStorage.removeItem('currentPlayer');
  }, []);
  
  // Reconnection state
  const reconnectionAttempts = useRef<number>(0);
  const maxReconnectionAttempts = 5;
  const reconnectionDelay = 3000; // 3 seconds
  const lastEventId = useRef<string | null>(null);

  // Operation timeouts
  const operationTimeouts = useRef<{ [key: string]: NodeJS.Timeout }>({});
  const defaultOperationTimeout = 10000; // 10 seconds

  // Helper functions
  const handleError = useCallback((errorResponse: ErrorResponse) => {
    let error: GameError;
    
    switch (errorResponse.code) {
      case WebSocketErrorCode.CONNECTION_ERROR:
        error = {
          type: GameErrorType.CONNECTION,
          message: errorResponse.message,
          recoverable: true,
          retryable: true,
          details: errorResponse.details
        };
        break;
      case WebSocketErrorCode.INVALID_MOVE:
      case WebSocketErrorCode.INVALID_GAME_ID:
      case WebSocketErrorCode.INVALID_STATE:
        error = {
          type: GameErrorType.VALIDATION,
          message: errorResponse.message,
          recoverable: false,
          retryable: false,
          details: errorResponse.details
        };
        break;
      case WebSocketErrorCode.TIMEOUT:
        error = {
          type: GameErrorType.TIMEOUT,
          message: errorResponse.message,
          recoverable: true,
          retryable: true,
          details: errorResponse.details
        };
        break;
      case WebSocketErrorCode.GAME_ENDED:
        error = {
          type: GameErrorType.GAME_STATE,
          message: errorResponse.message,
          recoverable: false,
          retryable: false,
          details: errorResponse.details
        };
        break;
      default:
        error = {
          type: GameErrorType.SERVER,
          message: errorResponse.message,
          recoverable: false,
          retryable: false,
          details: errorResponse.details
        };
    }

    setError(error);
    logger.error('Game error', { 
      component: 'useMultiplayerGame',
      data: { error, original: errorResponse }
    });
  }, []);

  const clearOperationTimeout = useCallback((operationId: string) => {
    if (operationTimeouts.current[operationId]) {
      clearTimeout(operationTimeouts.current[operationId]);
      delete operationTimeouts.current[operationId];
    }
  }, []);

  const setOperationTimeout = useCallback((operationId: string, callback: () => void) => {
    clearOperationTimeout(operationId);
    operationTimeouts.current[operationId] = setTimeout(() => {
      handleError({
        code: WebSocketErrorCode.TIMEOUT,
        message: `Operation ${operationId} timed out`,
        details: { operationId }
      });
      callback();
    }, defaultOperationTimeout);
  }, [handleError]);

  const attemptReconnection = useCallback(() => {
    if (!socket) return;

    if (reconnectionAttempts.current >= maxReconnectionAttempts) {
      setConnectionState(ConnectionState.ERROR);
      handleError({
        code: WebSocketErrorCode.CONNECTION_ERROR,
        message: 'Max reconnection attempts reached',
        details: { attempts: reconnectionAttempts.current }
      });
      clearGameState();
      return;
    }

    setConnectionState(ConnectionState.RECONNECTING);
    reconnectionAttempts.current += 1;

    const reconnectionData: ReconnectionData = {
      gameId: gameId || '',
      playerNumber: playerNumber || Player.First,
      lastEventId: lastEventId.current || undefined,
      timestamp: Date.now()
    };

    logger.info('Attempting reconnection', { 
      component: 'useMultiplayerGame',
      data: { 
        attempt: reconnectionAttempts.current,
        reconnectionData
      }
    });

    // Try to reconnect using existing socket
    socket.io.opts.query = {
      reconnection: true,
      ...reconnectionData
    };
    socket.connect();
  }, [gameId, playerNumber, handleError]);

  // Save state to localStorage when it changes
  useEffect(() => {
    if (gameId === null) {
      localStorage.removeItem('gameId');
    } else {
      localStorage.setItem('gameId', gameId);
    }
  }, [gameId]);

  useEffect(() => {
    if (playerNumber === null) {
      localStorage.removeItem('playerNumber');
    } else {
      localStorage.setItem('playerNumber', String(playerNumber));
    }
  }, [playerNumber]);

  useEffect(() => {
    if (gameState === null) {
      localStorage.removeItem('gameState');
    } else {
      localStorage.setItem('gameState', JSON.stringify(gameState));
    }
  }, [gameState]);

  useEffect(() => {
    localStorage.setItem('currentPlayer', String(currentPlayer));
  }, [currentPlayer]);

  // Initialize socket connection
  useEffect(() => {
    if (!socket) return;

    socket.on('connect', () => {
      logger.info('Socket connected', { 
        component: 'useMultiplayerGame',
        data: { 
          socketId: socket.id,
          transport: socket.io.engine.transport.name,
          protocol: socket.io.engine.protocol,
          connected: socket.connected,
          readyState: socket.io.engine.readyState,
          upgrading: socket.io.engine.upgrading,
          upgradeError: socket.io.engine.upgradeError,
        }
      });
      setConnectionState(ConnectionState.CONNECTED);
      reconnectionAttempts.current = 0;
      setError(null);

      // If we were in a game, attempt to rejoin
      if (gameId && playerNumber !== null) {
        socket.emit(WebSocketEvents.Reconnect, {
          gameId,
          playerNumber,
          lastEventId: lastEventId.current
        });
      }
    });

    socket.on('disconnect', (reason) => {
      logger.warn('Socket disconnected', { 
        component: 'useMultiplayerGame',
        data: { reason }
      });
      setConnectionState(ConnectionState.DISCONNECTED);

      if (reason === 'io server disconnect') {
        // Сервер разорвал соединение, не пытаемся переподключиться
        handleError({
          code: WebSocketErrorCode.CONNECTION_ERROR,
          message: 'Server terminated the connection',
          details: { reason }
        });
      } else {
        // Автоматически пытаемся переподключиться через reconnectionDelay
        setTimeout(attemptReconnection, reconnectionDelay);
      }
    });

    socket.on('connect_error', (error) => {
      logger.error('Socket connection error', { 
        component: 'useMultiplayerGame',
        data: { error: error.message }
      });
      setConnectionState(ConnectionState.ERROR);
      handleError({
        code: WebSocketErrorCode.CONNECTION_ERROR,
        message: 'Failed to connect to server',
        details: { error: error.message }
      });
    });

    // Check initial connection state
    if (socket.connected) {
      setConnectionState(ConnectionState.CONNECTED);
    }

    return () => {
      logger.info('Cleaning up socket listeners', { component: 'useMultiplayerGame' });
      // Очищаем все таймауты операций
      Object.keys(operationTimeouts.current).forEach(clearOperationTimeout);
      socket.removeAllListeners();
    };
  }, [socket, gameId, playerNumber]);

  // Socket event listeners
  useEffect(() => {
    if (!socket) return;

    const handlers = {
      [WebSocketEvents.GameCreated]: ({ gameId, eventId }: { gameId: string, eventId: string }) => {
        logger.socketEvent(WebSocketEvents.GameCreated, { gameId, eventId }, 'in');
        setGameId(gameId);
        setPlayerNumber(Player.First);
        lastEventId.current = eventId;
        setError(null);
        clearOperationTimeout('createGame');
      },

      [WebSocketEvents.GameJoined]: ({ gameId, eventId }: { gameId: string, eventId: string }) => {
        logger.socketEvent(WebSocketEvents.GameJoined, { gameId, eventId }, 'in');
        setGameId(gameId);
        setPlayerNumber(Player.Second);
        lastEventId.current = eventId;
        setError(null);
        clearOperationTimeout('joinGame');
      },

      [WebSocketEvents.GameStarted]: ({ gameState, currentPlayer, eventId }: { gameState: IGameState; currentPlayer: Player, eventId: string }) => {
        logger.debug('[GameStarted] Handler called', {
          component: 'useMultiplayerGame',
          data: { 
            gameId,
            playerNumber,
            currentGameState: gameState,
            newCurrentPlayer: currentPlayer,
            eventId,
            socketId: socket?.id,
            listeners: socket.listeners(WebSocketEvents.GameStarted).length,
            handlerRegistrationTime: Date.now()
          }
        });
        logger.socketEvent(WebSocketEvents.GameStarted, { gameState, currentPlayer, eventId }, 'in');
        if (!validateGameState(gameState)) {
          handleError({
            code: WebSocketErrorCode.INVALID_STATE,
            message: 'Invalid game state received',
            details: { gameState }
          });
          return;
        }
        setGameState(gameState);
        setCurrentPlayer(currentPlayer);
        lastEventId.current = eventId;
        setError(null);
      },

      [WebSocketEvents.GameStateUpdated]: ({ gameState, currentPlayer, eventId }: { gameState: IGameState; currentPlayer: Player, eventId: string }) => {
        logger.socketEvent(WebSocketEvents.GameStateUpdated, { gameState, currentPlayer, eventId }, 'in');
        if (!validateGameState(gameState)) {
          handleError({
            code: WebSocketErrorCode.INVALID_STATE,
            message: 'Invalid game state received',
            details: { gameState }
          });
          return;
        }
        setGameState(gameState);
        setCurrentPlayer(currentPlayer);
        lastEventId.current = eventId;
        setError(null);
        setAvailableReplaces([]);
        clearOperationTimeout('makeMove');
      },

      [WebSocketEvents.AvailableReplaces]: ({ moves, eventId }: { moves: GameMove[], eventId: string }) => {
        logger.socketEvent(WebSocketEvents.AvailableReplaces, { moves, eventId }, 'in');
        setAvailableReplaces(moves);
        lastEventId.current = eventId;
      },

      [WebSocketEvents.GameOver]: ({ gameState, winner, eventId }: { gameState: IGameState; winner: Player | null, eventId: string }) => {
        logger.socketEvent(WebSocketEvents.GameOver, { gameState, winner, eventId }, 'in');
        if (!validateGameState(gameState)) {
          handleError({
            code: WebSocketErrorCode.INVALID_STATE,
            message: 'Invalid game state received',
            details: { gameState }
          });
          return;
        }
        setGameState(gameState);
        lastEventId.current = eventId;
        handleError({
          code: WebSocketErrorCode.GAME_ENDED,
          message: winner === null ? 'Game ended in a draw!' : `${winner === Player.First ? 'First' : 'Second'} player won!`,
          recoverable: false,
          retryable: false,
          details: { winner }
        });
      },

      [WebSocketEvents.Error]: (errorResponse: ErrorResponse) => {
        logger.socketEvent(WebSocketEvents.Error, { error: errorResponse }, 'in');
        handleError(errorResponse);
        if (!errorResponse.retryable) {
          clearGameState();
        }
      },

      [WebSocketEvents.PlayerDisconnected]: ({ player, eventId }: { player: Player, eventId: string }) => {
        logger.socketEvent(WebSocketEvents.PlayerDisconnected, { player, eventId }, 'in');
        lastEventId.current = eventId;
        handleError({
          code: WebSocketErrorCode.CONNECTION_ERROR,
          message: `Player ${player} disconnected`,
          recoverable: true,
          retryable: true,
          details: { player }
        });
      }
    };

    // Set up socket event handlers once
    logger.debug('Current socket event listeners', {
      component: 'useMultiplayerGame',
      data: Object.keys(handlers).reduce((acc, event) => ({
        ...acc,
        [event]: socket.listeners(event).length
      }), {})
    });

    // Remove any existing handlers first
    Object.keys(handlers).forEach((event) => {
      socket.removeAllListeners(event);
    });

    // Add new handlers
      logger.debug('Setting up socket event handlers', {
        component: 'useMultiplayerGame',
        data: {
          currentHandlers: socket.listeners('GameCreated').length,
          events: Object.keys(handlers)
        }
      });
      
      Object.entries(handlers).forEach(([event, handler]) => {
        logger.debug(`Registering handler for ${event}`, {
          component: 'useMultiplayerGame',
          data: {
            event,
            existingHandlers: socket.listeners(event).length
          }
        });
        socket.on(event, handler);
      });

    // Cleanup on unmount only
    return () => {
      logger.debug('Cleaning up socket event handlers', {
        component: 'useMultiplayerGame',
        data: {
          events: Object.keys(handlers),
          handlersBeforeCleanup: Object.keys(handlers).map(event => ({
            event,
            count: socket.listeners(event).length
          }))
        }
      });

      Object.keys(handlers).forEach((event) => {
        socket.off(event);
      });

      logger.debug('Socket event handlers after cleanup', {
        component: 'useMultiplayerGame',
        data: {
          handlersAfterCleanup: Object.keys(handlers).map(event => ({
            event,
            count: socket.listeners(event).length
          }))
        }
      });
    };
  }, [socket, handleError, validateGameState, clearOperationTimeout]);

  const createGame = useCallback(async () => {
    try {
      logger.info('Creating new game', {
        component: 'useMultiplayerGame'
      });

      await gameManager.current.createGame();
      
      logger.debug('Game created successfully', { 
        component: 'useMultiplayerGame'
      });
    } catch (error) {
      const networkError = error as INetworkError;
      logger.error('Failed to create game', { 
        component: 'useMultiplayerGame',
        data: { error: networkError }
      });
    }
  }, []);

  const joinGame = useCallback(async (gameId: UUID): Promise<IJoinGameResult> => {
    try {
      logger.info('Joining game', {
        component: 'useMultiplayerGame',
        data: { gameId }
      });

      const result = await gameManager.current.joinGame(gameId);
      
      logger.debug('Game joined successfully', { 
        component: 'useMultiplayerGame',
        data: { gameId, playerNumber: result.playerNumber }
      });
      
      return result;
    } catch (error) {
      const networkError = error as INetworkError;
      logger.error('Failed to join game', { 
        component: 'useMultiplayerGame',
        data: { error: networkError }
      });
      throw error;
    }
  }, []);

  const makeMove = useCallback(async (x: number, y: number) => {
    try {
      const move: IGameMove = {
        position: { x, y },
        timestamp: Date.now()
      };

      // Use GameStateManager to make the move
      await gameManager.current.makeMove(move);
      
      logger.debug('Move made', { 
        component: 'useMultiplayerGame',
        data: { move }
      });
    } catch (error) {
      const networkError = error as INetworkError;
      logger.error('Failed to make move', { 
        component: 'useMultiplayerGame',
        data: { error: networkError }
      });
    }
  }, []);

  const endTurn = useCallback(async () => {
    try {
      logger.info('Ending turn', {
        component: 'useMultiplayerGame'
      });

      await gameManager.current.endTurn();
      
      logger.debug('Turn ended successfully', { 
        component: 'useMultiplayerGame'
      });
    } catch (error) {
      const networkError = error as INetworkError;
      logger.error('Failed to end turn', { 
        component: 'useMultiplayerGame',
        data: { error: networkError }
      });
      throw error;
    }
  }, []);
      handleError({
        code: WebSocketErrorCode.CONNECTION_ERROR,
        message: 'Cannot end turn - not connected to server',
        details: { connectionState }
      });
      return;
    }

    // Проверяем, наш ли сейчас ход
    if (playerNumber !== currentPlayer) {
      handleError({
        code: WebSocketErrorCode.NOT_YOUR_TURN,
        message: 'Cannot end turn - not your turn',
        details: { currentPlayer, playerNumber }
      });
      return;
    }

    logger.socketEvent(WebSocketEvents.EndTurn, { gameId }, 'out');
    socket.emit(WebSocketEvents.EndTurn, { gameId });
    setOperationTimeout('endTurn', () => {
      handleError({
        code: WebSocketErrorCode.TIMEOUT,
        message: 'End turn operation timed out',
        details: {}
      });
    });
  }, [socket, gameId, connectionState, currentPlayer, playerNumber, handleError, setOperationTimeout]);

  const isMyTurn = playerNumber === currentPlayer;

  return {
    // Game state
    gameId,
    playerNumber,
    gameState,
    currentPlayer,
    isMyTurn,
    availableReplaces,
    
    // Connection state
    connectionState,
    error,
    
    // Actions
    createGame,
    joinGame,
    makeMove,
    endTurn,
    
    // Computed
    isConnected: connectionState === ConnectionState.CONNECTED,
    isConnecting: connectionState === ConnectionState.CONNECTING || connectionState === ConnectionState.RECONNECTING,
    isError: connectionState === ConnectionState.ERROR,
    canRetry: error?.retryable || false,
    canRecover: error?.recoverable || false
  }
}