# План упрощения архитектуры проекта

## Текущие проблемы

1. Избыточная сложность сервисов:
   - Множество мелких сервисов с пересекающейся функциональностью
   - Сложные взаимосвязи между сервисами
   - Дублирование логики в разных местах
   - Избыточные уровни абстракции

2. Раздутая система типов:
   - Множество пересекающихся интерфейсов
   - Сложная иерархия типов
   - Дублирование типов между клиентом и сервером

3. Сложная система хранения данных:
   - Разделение на Redis и MongoDB без явной необходимости
   - Избыточное кеширование
   - Сложная система TTL и очистки данных

## План упрощения

### Этап 1: Упрощение сервисов (MVP)

1. Объединение EventService и GameService
   - Перенести логику создания событий в GameService
   - Упростить структуру событий
   - Удалить промежуточное хранение событий в Redis
   - Отправлять события напрямую через WebSocket
   ```typescript
   // Было
   await this.eventService.createGameStartedEvent();
   // Станет
   this.emit('gameStarted', { /* game data */ });
   ```

2. Объединение хранилищ
   - Объединить GameStorageService и RedisService в единый StorageService
   - Использовать Redis как основное хранилище для MVP
   - Упростить структуры хранения данных
   ```typescript
   // Было
   class GameStorageService { /* ... */ }
   class RedisService { /* ... */ }
   // Станет
   class StorageService { /* ... */ }
   ```

3. Интеграция GameLogicService
   - Перенести логику в GameService
   - Оставить только необходимые методы
   - Упростить интерфейсы
   ```typescript
   // Было
   GameLogicService.applyMove(state, move);
   // Станет
   GameService.prototype.applyMove(move);
   ```

### Этап 2: Упрощение системы типов

1. Упрощение игровых типов
   ```typescript
   // Было
   interface IGameState {
     board: Board;
     scores: IGameScores;
     gameOver: boolean;
     winner: PlayerNumber | null;
     // ... много других полей
   }
   // Станет
   interface GameState {
     board: number[][];
     scores: [number, number];
     status: 'active' | 'finished';
     winner?: 1 | 2;
   }
   ```

2. Упрощение событий
   ```typescript
   // Было
   interface IGameCreatedEvent extends GameEvent {
     type: 'game_created';
     data: {
       gameId: string;
       status: GameStatus;
       createdAt: number;
     };
   }
   // Станет
   interface GameEvent {
     type: 'created' | 'started' | 'moved' | 'finished';
     gameId: string;
     payload?: any;
   }
   ```

3. Единые типы для клиента и сервера
   - Вынести общие типы в shared
   - Упростить структуры данных
   - Использовать более простые примитивные типы

### Этап 3: Упрощение хранения данных

1. Использование Redis как основного хранилища
   - Упростить схему данных
   - Оптимизировать структуры для Redis
   - Удалить избыточное кеширование

2. Упрощение TTL и очистки данных
   ```typescript
   // Было
   class TTLStrategy {
     calculateTTL(): number { /* ... */ }
   }
   // Станет
   const DEFAULT_TTL = 3600; // 1 hour
   ```

3. Минимизация хранимых данных
   - Хранить только необходимые данные для MVP
   - Упростить структуры хранения
   - Удалить избыточные индексы и связи

## График реализации

1. Этап 1 (MVP - срочные изменения):
   - День 1-2: Объединение EventService и GameService
   - День 3-4: Объединение хранилищ
   - День 5: Интеграция GameLogicService

2. Этап 2 (после стабилизации MVP):
   - День 6-7: Упрощение игровых типов
   - День 8-9: Упрощение событий
   - День 10: Унификация типов клиент/сервер

3. Этап 3 (оптимизация):
   - День 11-12: Оптимизация Redis
   - День 13: Упрощение TTL
   - День 14: Очистка и тестирование

## Риски и митигация

1. Риск: Потеря функциональности при упрощении
   - Митигация: Тщательное тестирование после каждого изменения
   - Поддержание списка критических функций

2. Риск: Проблемы с обратной совместимостью
   - Митигация: Сохранение старых интерфейсов до полного перехода
   - Временное дублирование кода где необходимо

3. Риск: Потеря производительности
   - Митигация: Тестирование производительности
   - Профилирование критических операций

## Метрики успеха

1. Количественные:
   - Уменьшение количества классов на 70%
   - Уменьшение количества строк кода на 50%
   - Уменьшение времени загрузки на 30%

2. Качественные:
   - Улучшение читаемости кода
   - Упрощение процесса разработки
   - Ускорение внедрения новых функций

## Процесс рефакторинга

1. Для каждого изменения:
   - Создать ветку фичи
   - Написать тесты для критической функциональности
   - Внести изменения
   - Провести тестирование
   - Обновить документацию
   - Получить код-ревью
   - Слить в основную ветку

2. Приоритеты при рефакторинге:
   - Сначала критические компоненты
   - Минимальные изменения за раз
   - Постоянное тестирование
   - Обновление документации

## Точки принятия решений

После каждого этапа необходимо:
1. Оценить результаты изменений
2. Проверить метрики
3. Принять решение о продолжении или корректировке плана
4. Обсудить следующие шаги с командой